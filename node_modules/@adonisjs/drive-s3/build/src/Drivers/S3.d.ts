/// <reference types="@adonisjs/logger/build/adonis-typings/logger" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="@adonisjs/drive/build/adonis-typings" />
/// <reference types="node" />
import { Readable } from 'stream';
import { Upload } from '@aws-sdk/lib-storage';
import { LoggerContract } from '@ioc:Adonis/Core/Logger';
import { Visibility, WriteOptions, ContentHeaders, S3DriverConfig, S3DriverContract, DriveFileStats } from '@ioc:Adonis/Core/Drive';
import { Tag, S3Client } from '@aws-sdk/client-s3';
/**
 * An implementation of the s3 driver for AdonisJS drive
 */
export declare class S3Driver implements S3DriverContract {
    private config;
    private logger;
    /**
     * Reference to the s3 client
     */
    adapter: S3Client;
    /**
     * Name of the driver
     */
    name: 's3';
    /**
     * We cache the bucket URL to avoid resolving it again
     * and again
     */
    private cachedBucketUrl;
    /**
     * The URI for the grant applicable to public
     */
    private publicGrantUri;
    constructor(config: S3DriverConfig, logger: LoggerContract);
    /**
     * Transforms the write options to S3 properties
     */
    private transformWriteOptions;
    /**
     * Transform content headers to S3 response content type
     */
    private transformContentHeaders;
    /**
     * Returns the URL for the bucket
     */
    private getBucketUrl;
    /**
     * Returns a new instance of the s3 driver with a custom runtime
     * bucket
     */
    bucket(bucket: string): S3Driver;
    /**
     * Returns the file contents as a buffer. The buffer return
     * value allows you to self choose the encoding when
     * converting the buffer to a string.
     */
    get(location: string): Promise<Buffer>;
    /**
     * Returns the file contents as a stream
     */
    getStream(location: string): Promise<Readable>;
    /**
     * A boolean to find if the location path exists or not
     */
    exists(location: string): Promise<boolean>;
    /**
     * Not supported
     */
    getVisibility(location: string): Promise<Visibility>;
    /**
     * Returns the file stats
     */
    getStats(location: string): Promise<DriveFileStats>;
    /**
     * Returns the signed url for a given path
     */
    getSignedUrl(location: string, options?: ContentHeaders & {
        expiresIn?: string | number;
    }): Promise<string>;
    /**
     * Returns URL to a given path
     */
    getUrl(location: string): Promise<string>;
    /**
     * Write string|buffer contents to a destination. The missing
     * intermediate directories will be created (if required).
     */
    put(location: string, contents: Buffer | string, options?: WriteOptions): Promise<void>;
    /**
     * Write a stream to a destination. The missing intermediate
     * directories will be created (if required).
     */
    putStream(location: string, contents: NodeJS.ReadableStream, options?: WriteOptions & {
        multipart?: boolean;
        queueSize?: number;
        partSize?: number;
        leavePartsOnError?: boolean;
        tags?: Tag[];
        tap?: (stream: Upload) => void;
    }): Promise<void>;
    /**
     * Not supported
     */
    setVisibility(location: string, visibility: Visibility): Promise<void>;
    /**
     * Remove a given location path
     */
    delete(location: string): Promise<void>;
    /**
     * Copy a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    copy(source: string, destination: string, options?: WriteOptions): Promise<void>;
    /**
     * Move a given location path from the source to the desination.
     * The missing intermediate directories will be created (if required)
     */
    move(source: string, destination: string, options?: WriteOptions): Promise<void>;
}
